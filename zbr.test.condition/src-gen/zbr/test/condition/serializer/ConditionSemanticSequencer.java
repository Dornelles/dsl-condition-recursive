/*
 * generated by Xtext 2.28.0
 */
package zbr.test.condition.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import zbr.test.condition.condition.BinaryTermOperator;
import zbr.test.condition.condition.ComparisonOperator;
import zbr.test.condition.condition.ConditionPackage;
import zbr.test.condition.condition.ConditionalExpression;
import zbr.test.condition.condition.LogicalOpeartor;
import zbr.test.condition.condition.MaxNumberOfOperation;
import zbr.test.condition.condition.MessageContent;
import zbr.test.condition.condition.Model;
import zbr.test.condition.condition.SessionInterval;
import zbr.test.condition.condition.TimeInterval;
import zbr.test.condition.condition.Timeout;
import zbr.test.condition.condition.UnaryTermOperator;
import zbr.test.condition.condition.WeekDaysInterval;
import zbr.test.condition.services.ConditionGrammarAccess;

@SuppressWarnings("all")
public class ConditionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ConditionGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ConditionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ConditionPackage.BINARY_TERM_OPERATOR:
				sequence_CompositeCondition(context, (BinaryTermOperator) semanticObject); 
				return; 
			case ConditionPackage.COMPARISON_OPERATOR:
				sequence_ComparisonOperator(context, (ComparisonOperator) semanticObject); 
				return; 
			case ConditionPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case ConditionPackage.LOGICAL_OPEARTOR:
				sequence_LogicalOpeartor(context, (LogicalOpeartor) semanticObject); 
				return; 
			case ConditionPackage.MAX_NUMBER_OF_OPERATION:
				sequence_MaxNumberOfOperation(context, (MaxNumberOfOperation) semanticObject); 
				return; 
			case ConditionPackage.MESSAGE_CONTENT:
				sequence_MessageContent(context, (MessageContent) semanticObject); 
				return; 
			case ConditionPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ConditionPackage.SESSION_INTERVAL:
				sequence_SessionInterval(context, (SessionInterval) semanticObject); 
				return; 
			case ConditionPackage.TIME_INTERVAL:
				sequence_TimeInterval(context, (TimeInterval) semanticObject); 
				return; 
			case ConditionPackage.TIMEOUT:
				sequence_Timeout(context, (Timeout) semanticObject); 
				return; 
			case ConditionPackage.UNARY_TERM_OPERATOR:
				sequence_Negation(context, (UnaryTermOperator) semanticObject); 
				return; 
			case ConditionPackage.WEEK_DAYS_INTERVAL:
				sequence_WeekDaysInterval(context, (WeekDaysInterval) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ComparisonOperator returns ComparisonOperator
	 *
	 * Constraint:
	 *     (
	 *         symbol='&lt;=' | 
	 *         symbol='&gt;=' | 
	 *         symbol='&gt;' | 
	 *         symbol='&lt;' | 
	 *         symbol='!=' | 
	 *         symbol='=='
	 *     )
	 * </pre>
	 */
	protected void sequence_ComparisonOperator(ISerializationContext context, ComparisonOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns BinaryTermOperator
	 *     CompositeCondition returns BinaryTermOperator
	 *     CompositeCondition.BinaryTermOperator_1_0 returns BinaryTermOperator
	 *     Negation returns BinaryTermOperator
	 *     Term returns BinaryTermOperator
	 *
	 * Constraint:
	 *     (left=CompositeCondition_BinaryTermOperator_1_0 (symbol='AND' | symbol='OR') right=Negation)
	 * </pre>
	 */
	protected void sequence_CompositeCondition(ISerializationContext context, BinaryTermOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionalExpression returns ConditionalExpression
	 *
	 * Constraint:
	 *     (beforeSymbol=LogicalOpeartor? conditionParam=Condition condition=Condition aftetrSymbol=LogicalOpeartor?)
	 * </pre>
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalOpeartor returns LogicalOpeartor
	 *
	 * Constraint:
	 *     (symbol='AND' | symbol='OR')
	 * </pre>
	 */
	protected void sequence_LogicalOpeartor(ISerializationContext context, LogicalOpeartor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns MaxNumberOfOperation
	 *     CompositeCondition returns MaxNumberOfOperation
	 *     CompositeCondition.BinaryTermOperator_1_0 returns MaxNumberOfOperation
	 *     Negation returns MaxNumberOfOperation
	 *     Term returns MaxNumberOfOperation
	 *     MaxNumberOfOperation returns MaxNumberOfOperation
	 *
	 * Constraint:
	 *     (operationsNumber=INT timeUnit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_MaxNumberOfOperation(ISerializationContext context, MaxNumberOfOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.MAX_NUMBER_OF_OPERATION__OPERATIONS_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.MAX_NUMBER_OF_OPERATION__OPERATIONS_NUMBER));
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.MAX_NUMBER_OF_OPERATION__TIME_UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.MAX_NUMBER_OF_OPERATION__TIME_UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxNumberOfOperationAccess().getOperationsNumberINTTerminalRuleCall_2_0(), semanticObject.getOperationsNumber());
		feeder.accept(grammarAccess.getMaxNumberOfOperationAccess().getTimeUnitTimeUnitEnumRuleCall_4_0(), semanticObject.getTimeUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns MessageContent
	 *     CompositeCondition returns MessageContent
	 *     CompositeCondition.BinaryTermOperator_1_0 returns MessageContent
	 *     Negation returns MessageContent
	 *     Term returns MessageContent
	 *     MessageContent returns MessageContent
	 *
	 * Constraint:
	 *     (
	 *         content=STRING | 
	 *         (content=STRING timeUnit=TimeUnit) | 
	 *         (content=STRING comparisonOperator=ComparisonOperator value=STRING) | 
	 *         (content=STRING comparisonOperator=ComparisonOperator value=STRING timeUnit=TimeUnit)
	 *     )
	 * </pre>
	 */
	protected void sequence_MessageContent(ISerializationContext context, MessageContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (condition+=Condition | conditionalExpression+=ConditionalExpression)+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns UnaryTermOperator
	 *     CompositeCondition returns UnaryTermOperator
	 *     CompositeCondition.BinaryTermOperator_1_0 returns UnaryTermOperator
	 *     Negation returns UnaryTermOperator
	 *     Term returns UnaryTermOperator
	 *
	 * Constraint:
	 *     (symbol='NOT' condition=Term)
	 * </pre>
	 */
	protected void sequence_Negation(ISerializationContext context, UnaryTermOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.UNARY_TERM_OPERATOR__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.UNARY_TERM_OPERATOR__SYMBOL));
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.UNARY_TERM_OPERATOR__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.UNARY_TERM_OPERATOR__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationAccess().getSymbolNOTKeyword_1_1_0(), semanticObject.getSymbol());
		feeder.accept(grammarAccess.getNegationAccess().getConditionTermParserRuleCall_1_2_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns SessionInterval
	 *     CompositeCondition returns SessionInterval
	 *     CompositeCondition.BinaryTermOperator_1_0 returns SessionInterval
	 *     Negation returns SessionInterval
	 *     Term returns SessionInterval
	 *     SessionInterval returns SessionInterval
	 *
	 * Constraint:
	 *     (
	 *         (frequency=INT timeUnit=TimeUnit messagecontent=MessageContent) | 
	 *         (frequency=INT timeUnit=TimeUnit) | 
	 *         (frequency=INT timeUnit=TimeUnit value=STRING)
	 *     )
	 * </pre>
	 */
	protected void sequence_SessionInterval(ISerializationContext context, SessionInterval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns TimeInterval
	 *     CompositeCondition returns TimeInterval
	 *     CompositeCondition.BinaryTermOperator_1_0 returns TimeInterval
	 *     Negation returns TimeInterval
	 *     Term returns TimeInterval
	 *     TimeInterval returns TimeInterval
	 *
	 * Constraint:
	 *     (start=STRING end=STRING)
	 * </pre>
	 */
	protected void sequence_TimeInterval(ISerializationContext context, TimeInterval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.TIME_INTERVAL__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.TIME_INTERVAL__START));
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.TIME_INTERVAL__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.TIME_INTERVAL__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeIntervalAccess().getStartSTRINGTerminalRuleCall_2_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getTimeIntervalAccess().getEndSTRINGTerminalRuleCall_4_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Timeout
	 *     CompositeCondition returns Timeout
	 *     CompositeCondition.BinaryTermOperator_1_0 returns Timeout
	 *     Negation returns Timeout
	 *     Term returns Timeout
	 *     Timeout returns Timeout
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Timeout(ISerializationContext context, Timeout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.TIMEOUT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.TIMEOUT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeoutAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns WeekDaysInterval
	 *     CompositeCondition returns WeekDaysInterval
	 *     CompositeCondition.BinaryTermOperator_1_0 returns WeekDaysInterval
	 *     Negation returns WeekDaysInterval
	 *     Term returns WeekDaysInterval
	 *     WeekDaysInterval returns WeekDaysInterval
	 *
	 * Constraint:
	 *     (start=WeekDay end=WeekDay)
	 * </pre>
	 */
	protected void sequence_WeekDaysInterval(ISerializationContext context, WeekDaysInterval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.WEEK_DAYS_INTERVAL__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.WEEK_DAYS_INTERVAL__START));
			if (transientValues.isValueTransient(semanticObject, ConditionPackage.Literals.WEEK_DAYS_INTERVAL__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConditionPackage.Literals.WEEK_DAYS_INTERVAL__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWeekDaysIntervalAccess().getStartWeekDayEnumRuleCall_2_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getWeekDaysIntervalAccess().getEndWeekDayEnumRuleCall_4_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
}
